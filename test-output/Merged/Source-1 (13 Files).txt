--- INDEX ---
bin\cli.js
postcss.config.js
src\app.css
src\app.d.ts
src\app.html
src\lib\components\FileTreeNode.svelte
src\lib\index.ts
src\lib\processor.ts
src\lib\server\logger.js
src\lib\server\sys-utils.js
src\lib\templates.ts
src\lib\tree.ts
src\routes\+layout.svelte
------------------------------


==================================================
File: bin\cli.js
==================================================

#!/usr/bin/env node

import { spawn, exec } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';
import open from 'open';
import { randomUUID } from 'crypto';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Adjust path to point to the built server
const serverPath = path.join(__dirname, '../build/index.js');
const USER_CWD = process.cwd();
const PORT = 4567;
const SESSION_ID = randomUUID();

// --- Argument Parsing ---

const args = process.argv.slice(2);

const isDebug = args.includes('--debug') || args.includes('-d');

// Auto Mode Flags
const isAuto = args.includes('--auto') || args.includes('-a');
const isVault = args.includes('--vault') || args.includes('--global') || args.includes('-v');
const isIgnored = args.includes('--ignored') || args.includes('-i');

// Custom Path Parsing (-c "path" or --custom "path")
let customPath = null;
const customFlagIndex = args.indexOf('--custom') > -1 ? args.indexOf('--custom') : args.indexOf('-c');
if (customFlagIndex > -1 && args[customFlagIndex + 1]) {
    // Grab the next argument as the path
    customPath = args[customFlagIndex + 1];
    // Basic cleanup to remove quotes if user added them manually in a weird way,
    // though shell usually handles this.
    customPath = customPath.replace(/^"|"$/g, '').replace(/^'|'$/g, '');
}

// --------------------------------

// Calm initialization message
if (!isAuto) {
    console.log('\x1b[36m%s\x1b[0m', '‚Ä∫ Initializing TXT-Forge...');
} else {
    console.log('\x1b[36m%s\x1b[0m', '‚Ä∫ TXT-Forge Auto-Mode Initiated...');
    console.log('\x1b[90m%s\x1b[0m', `  Options: [Vault: ${isVault}] [Show Ignored: ${isIgnored}]`);
}

if (isDebug) console.log('\x1b[33m%s\x1b[0m', '‚Ä∫ Debug Mode Enabled');

async function killPort(port) {
    return new Promise((resolve) => {
        const isWin = process.platform === 'win32';
        const command = isWin
            ? `netstat -ano | findstr :${port}`
            : `lsof -i :${port} -t`;
        exec(command, (err, stdout) => {
            if (!stdout) return resolve();
            // Inform user we are preparing the environment, not "cleaning up a mess"
            console.log('\x1b[90m%s\x1b[0m', '‚Ä∫ Preparing local network environment...');

            const pids = stdout.trim().split(/\s+/);
            // Logic to kill PIDs (simplified for brevity, existing logic was fine, just needed silence)
             if (isWin) {
                 const lines = stdout.trim().split('\n');
                 const pid = lines[0].trim().split(/\s+/).pop();
                 if(pid) exec(`taskkill /PID ${pid} /F`, () => setTimeout(resolve, 500));
                 else resolve();
            } else {
                const pid = stdout.trim();
                if(pid) exec(`kill -9 ${pid}`, () => setTimeout(resolve, 500));
                else resolve();
            }
        });
    });
}

async function startServer() {
    await killPort(PORT);

    // In auto mode, we pipe stdout to 'ignore' to keep the CLI output clean from server logs
    // unless we are in debug mode.
    const stdioConfig = (isAuto && !isDebug) ? ['ignore', 'ignore', 'inherit'] : 'inherit';
    const server = spawn('node', [serverPath], {
        env: {
            ...process.env,
            PORT: PORT.toString(),
            TXT_FORGE_CWD: USER_CWD,
            ORIGIN: `http://localhost:${PORT}`,
            FORGE_SESSION_ID: SESSION_ID,
            node_env: 'production',
            TXT_FORGE_DEBUG: isDebug ? 'true' : 'false'
        },
        stdio: stdioConfig
    });
    const url = `http://localhost:${PORT}`;
    // Wait for server to start
    setTimeout(async () => {

        if (isAuto) {
            // --- AUTO MODE LOGIC ---
            try {
                console.log('\x1b[90m%s\x1b[0m', '‚Ä∫ Detecting stack and processing files...');

                // 1. Call the CLI-specific API endpoint
                const response = await fetch(`${url}/api/cli-forge`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        saveToVault: isVault,
                        includeIgnoredInTree: isIgnored,
                        customPath: customPath // Pass the path
                    })
                });
                const result = await response.json();

                if (result.success) {
                    console.log('\x1b[32m%s\x1b[0m', '‚úì Auto-Forge Complete!');

                    // Gitignore Warning
                    if (result.gitIgnoreModified) {
                        console.log('\x1b[33m%s\x1b[0m', '‚ö† Note: Added "TXT-Forge/" to your .gitignore file.');
                    }

                    console.log('\x1b[90m%s\x1b[0m', `  Detected: ${result.detectedIds.join(', ') || 'None'}`);
                    console.log('\x1b[36m%s\x1b[0m', `  Output:   ${result.outputPath}`);
                    console.log('\x1b[90m%s\x1b[0m', `  Generated ${result.files.length} file(s).`);

                    // Open the folder automatically
                    await open(result.outputPath);
                } else {
                    console.error('\x1b[31m%s\x1b[0m', '‚úï Error:', result.message);
                    if (result.ids) console.log('  Detected:', result.ids.join(', '));
                }
            } catch (e) {
                console.error('\x1b[31m%s\x1b[0m', '‚úï Failed to communicate with internal server.');
                if (isDebug) console.error(e);
            } finally {
                // Cleanup and Exit
                server.kill();
                process.exit(0);
            }
        } else {
            // --- UI MODE LOGIC ---
            console.log('\x1b[32m%s\x1b[0m', `‚úì Ready. Opening ${url}`);
            console.log('\x1b[90m%s\x1b[0m', '  (Press Ctrl+C to exit manually)');
            await open(url);
        }
    }, 1500); // Gave it slightly more time (1.5s) to ensure SvelteKit cold start is ready

    process.on('SIGINT', () => {
        server.kill();
        process.exit();
    });
}

startServer();



==================================================
File: postcss.config.js
==================================================

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



==================================================
File: src\app.css
==================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer utilities {
  .animate-fade-in-up {
    animation: fadeInUp 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    opacity: 0;
    transform: translateY(20px);
  }
  .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
  }
  .custom-scrollbar::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.02);
  }
  .custom-scrollbar::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.15);
      border-radius: 10px;
  }
  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
  }
}

/* NEW: Fixes layout shift */
html {
    scrollbar-gutter: stable;
}

body {
    @apply bg-slate-950 text-slate-200 overflow-x-hidden;
    /* UPDATED: Increased opacity from 0.1 to 0.15 for better visibility */
    background-image:
        radial-gradient(circle at 50% 0%, rgba(249, 115, 22, 0.15) 0%, transparent 60%),
        radial-gradient(circle at 0% 100%, rgba(124, 58, 237, 0.15) 0%, transparent 50%);
    background-attachment: fixed;
}



==================================================
File: src\app.d.ts
==================================================

// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};



==================================================
File: src\app.html
==================================================

<!DOCTYPE html>
<html lang="en" class="dark">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover" class="bg-slate-950 text-white h-full">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>



==================================================
File: src\lib\components\FileTreeNode.svelte
==================================================

<script lang="ts">

    import { slide } from 'svelte/transition';

    export let node: any;

    export let selectedPaths: Set<string>;

    export let folderDescendants: Map<string, string[]>;

    export let onToggle: (path: string, isFolder: boolean, forcedState?: boolean) => void;

    // NEW PROP: Closure to handle lazy loading

    export let onLoadChildren: (path: string) => Promise<void>;

    let expanded = false;

    let isLoading = false; // Local loading state

    // ... (Keep Check Logic) ...

    $: isSelfChecked = selectedPaths.has(node.path);

    let isIndeterminate = false;

    let isFullyChecked = false;

    $: {

        if (node.type === 'folder') {

            const allDescendants = folderDescendants.get(node.path) || [];

            // Handle Massive/Empty case:

            // If massive and no descendants loaded, relies purely on Self Check

            if (allDescendants.length === 0 && node.isMassive) {

                isFullyChecked = isSelfChecked;

                isIndeterminate = false;

            } else if (allDescendants.length > 0) {

                const selectedCount = allDescendants.reduce((acc, path) => acc + (selectedPaths.has(path) ? 1 : 0), 0);

                const totalSelected = selectedCount + (isSelfChecked ? 1 : 0);

                const totalItems = allDescendants.length + 1;

                isIndeterminate = totalSelected > 0 && totalSelected < totalItems;

                isFullyChecked = totalSelected === totalItems;

            } else {

                isFullyChecked = isSelfChecked;

            }

        } else {

            isFullyChecked = isSelfChecked;

        }

    }

    // UPDATED: Expandable if folder, even if children array is empty (Massive)

    $: hasChildren = node.children && node.children.length > 0;

    $: isExpandable = node.type === 'folder'; // Always expandable if folder

    async function handleExpand() {

        if (!isExpandable) return;

        

        // If expanding a massive folder with no children, Fetch!

        if (!expanded && node.isMassive && (!node.children || node.children.length === 0)) {

            isLoading = true;

            expanded = true; // Open immediately to show spinner

            await onLoadChildren(node.path);

            isLoading = false;

        } else {

            expanded = !expanded;

        }

    }

    function handleToggle() {

        const nextState = isIndeterminate ? true : !isSelfChecked;

        onToggle(node.path, node.type === 'folder', nextState);

    }

</script>

<div class="select-none">
    <div
        class="flex items-center gap-2 py-1 px-2 rounded-lg hover:bg-white/5 group transition-colors border border-transparent hover:border-orange-500/20"
        style="padding-left: {(node.depth * 1.25) + 0.5}rem"
    >

        <!-- UPDATED Expander -->
        <button
            on:click|stopPropagation={handleExpand}
            class="w-5 h-5 flex items-center justify-center rounded hover:bg-white/10 text-slate-500 transition-transform duration-200 {expanded ? 'rotate-90 text-orange-400' : ''} {isExpandable ? '' : 'invisible'}"
        >

            {#if isLoading}
                 <!-- Tiny Spinner -->
                 <svg class="animate-spin h-3 w-3 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            {:else}
                ‚ñ∂
            {/if}

        </button>

        <!-- Checkbox (Keep existing) -->
        <button
            on:click|stopPropagation={handleToggle}
            class="w-4 h-4 rounded border flex items-center justify-center transition-all

            {isFullyChecked || isIndeterminate

                ? 'bg-orange-600 border-orange-600 text-white shadow-[0_0_10px_rgba(2ea,88,12,0.4)]'

                : 'border-slate-700 bg-slate-900/50 hover:border-orange-500/50'}"
        >

            {#if isFullyChecked}

                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path></svg>

            {:else if isIndeterminate}

                <div class="w-2.5 h-0.5 bg-white rounded-full"></div>

            {/if}

        </button>

        <!-- Name -->

        <div class="flex items-center gap-2 text-sm font-mono truncate cursor-pointer flex-1" on:click={handleExpand}>

            {#if node.type === 'folder'}

                <span class="text-amber-500 opacity-90 drop-shadow-md">üìÅ</span>

                <span class="{isFullyChecked || isIndeterminate ? 'text-orange-100' : 'text-slate-500'} group-hover:text-orange-50 transition-colors">{node.name}</span>

                

                <!-- NEW: Massive Label -->

                {#if node.isMassive}

                    <span class="ml-2 text-[9px] uppercase border border-amber-900/50 text-amber-500/80 px-1.5 rounded bg-amber-950/30 tracking-wider">Massive</span>

                {/if}

            {:else}

                <span class="opacity-80 {node.isMedia ? 'grayscale opacity-50' : 'text-orange-400/80'}">

                    {node.isMedia ? 'üñºÔ∏è' : 'üìÑ'}

                </span>

                <span class="{isFullyChecked ? 'text-orange-200/80' : 'text-slate-500'} group-hover:text-white transition-colors {node.isMedia && !isFullyChecked ? 'italic opacity-50' : ''}">

                    {node.name}

                </span>

            {/if}

            {#if node.isIgnored && !isFullyChecked}

                <span class="ml-2 text-[9px] uppercase border border-slate-800 text-slate-600 px-1.5 rounded bg-slate-950">Ignored</span>

            {/if}

            {#if node.isMedia && !isFullyChecked}

                <span class="ml-2 text-[9px] uppercase border border-slate-800 text-slate-700 px-1.5 rounded bg-slate-950">Media</span>

            {/if}

        </div>

    </div>

    <!-- Children -->

    <!-- Check hasChildren OR isMassive (to keep div ready for injection) -->

    {#if expanded && (hasChildren || node.isMassive)}

        <div transition:slide|local={{ duration: 200 }}>

            {#if node.children}

                {#each node.children as child (child.path)}

                    <svelte:self

                        node={child}

                        {selectedPaths}

                        {folderDescendants}

                        {onToggle}

                        {onLoadChildren}

                    />

                {/each}

            {/if}

        </div>

    {/if}

</div>


==================================================
File: src\lib\index.ts
==================================================

// place files you want to import through the `$lib` alias in this folder.



==================================================
File: src\lib\processor.ts
==================================================

import fs from 'fs/promises';
import path from 'path';
import os from 'os';
import { templates, type CodebaseTemplate } from '$lib/templates';

// ADD THIS:
import { logDebug } from '$lib/server/logger.js';

export type SaveMode = 'root' | 'global' | 'custom';

export interface ProcessConfig {
    sourceDir: string;
    saveMode: SaveMode;
    customPath?: string;
    templateIds: string[];
    maxChars: number;
    // NEW: Optional explicit list of files to process (overrides templates)
    selectedFiles?: string[];
    // NEW: Toggle for tree context
    includeIgnoredInTree?: boolean;
}

interface ProcessResult {
    success: boolean;
    message: string;
    outputPath: string;
    files: string[];
    gitIgnoreModified?: boolean; // <--- NEW FIELD
}

export interface DetectionResult {
    ids: string[];
    reasons: Record<string, string[]>; // templateId -> list of filenames that triggered it
    gitStatus: 'none' | 'clean' | 'ignored'; // 'none' = no .git, 'clean' = has .git but no ignore entry, 'ignored' = already configured
}

// Regex to find safe places to split code
const SAFE_SPLIT_REGEX = /\n(?=(function|class|export|interface|type|def|func|const|let|var|public|private|protected|struct|impl|package|import)\s)/g;

// --- CONSTANTS FOR STRICT DETECTION ---

// Extensions that are too common to act as proof of a specific framework
// UPDATED: Added .py, .php, .java, .rb, .go, .rs to prevent frameworks from stealing generic language attribution
const GENERIC_EXTENSIONS = new Set([
    '.js', '.jsx', '.ts', '.tsx', '.css', '.scss', '.html', '.json', '.md', '.yaml', '.yml',
    '.py', '.php', '.java', '.rb', '.go', '.rs', '.c', '.cpp', '.h'
]);

// Triggers that are too common to prove a specific framework
const GENERIC_TRIGGERS = new Set([
    'package.json', 'README.md', '.gitignore', '.env', '.editorconfig', 'LICENSE', 'tsconfig.json',
    'vite.config.ts', 'vite.config.js', 'vite.config.mts', 'vite.config.mjs'
]);

const FRAMEWORK_DEPENDENCIES: Record<string, string[]> = {
    'react': ['javascript', 'typescript', 'html-css'],
    'nextjs': ['react', 'javascript', 'typescript', 'html-css'],
    'vuejs': ['javascript', 'typescript', 'html-css'],
    'nuxtjs': ['vuejs', 'javascript', 'typescript', 'html-css'],
    'sveltekit': ['javascript', 'typescript', 'html-css'],
    'angular': ['typescript', 'html-css'],
    'astro': ['javascript', 'typescript', 'html-css'],
    'remix': ['react', 'javascript', 'typescript', 'html-css'],
    'solidjs': ['javascript', 'typescript', 'html-css'],
    'qwik': ['javascript', 'typescript', 'html-css'],
    'laravel': ['php', 'html-css'],
    'django': ['python', 'html-css'],
    'flask': ['python', 'html-css'],
    'spring-boot': ['java'],
    'flutter': ['dart'],
    'rails': ['ruby', 'html-css']
};

// --- PUBLIC API ---

/**
 * 1. Detect Codebase
 * Returns detected IDs, the files that triggered them, and git status.
 */
export async function detectCodebase(sourceDir: string): Promise<DetectionResult> {
    // ADD THIS:
    logDebug(`Starting detection in: ${sourceDir}`);

    try {
        const detectedIds = new Set<string>();
        const reasons: Record<string, string[]> = {};
        let gitStatus: 'none' | 'clean' | 'ignored' = 'none';

        // 1. Scan environment
        // ADD THIS:
        logDebug('Reading root directory...');
        const rootFiles = await fs.readdir(sourceDir);

        // Check for git and specifically .gitignore status
        if (rootFiles.includes('.git')) {
            if (rootFiles.includes('.gitignore')) {
                try {
                    const gitIgnoreContent = await fs.readFile(path.join(sourceDir, '.gitignore'), 'utf-8');
                    if (gitIgnoreContent.includes('TXT-Forge')) {
                        gitStatus = 'ignored'; // Already has it
                    } else {
                        gitStatus = 'clean'; // Has .git, but needs update
                    }
                } catch (e) {
                    gitStatus = 'clean'; // Fallback
                }
            } else {
                gitStatus = 'clean'; // Has .git, needs .gitignore created
            }
        }

        const foundExtensions = await deepScanExtensions(sourceDir, 4);

        // 2. Iterate all templates
        for (const t of templates) {
            const foundTriggers: string[] = [];
            let strongEvidenceFound = false;

            // CHECK A: Unique Config Files (Triggers)
            for (const trigger of t.triggers) {
                if (GENERIC_TRIGGERS.has(trigger)) continue;

                if (trigger.startsWith('*')) {
                    const suffix = trigger.slice(1);
                    const matches = rootFiles.filter(f => f.endsWith(suffix));
                    if (matches.length > 0) {
                        foundTriggers.push(...matches);
                    }
                } else {
                    if (rootFiles.includes(trigger)) {
                        foundTriggers.push(trigger);
                    }
                }
            }

            if (foundTriggers.length > 0) {
                strongEvidenceFound = true;
            }

            // CHECK B: Unique File Extensions
            const isGenericLanguage = ['javascript', 'typescript', 'html-css', 'python', 'java', 'csharp', 'go', 'rust', 'php', 'ruby'].includes(t.id);

            if (!strongEvidenceFound) {
                const relevantExtensions = t.extensions.filter(ext => {
                    if (isGenericLanguage) return true;
                    return !GENERIC_EXTENSIONS.has(ext);
                });

                for (const ext of relevantExtensions) {
                    if (foundExtensions.has(ext)) {
                        strongEvidenceFound = true;
                        if (!foundTriggers.includes(`*${ext} files`)) foundTriggers.push(`*${ext} files`);
                    }
                }
            }

            if (strongEvidenceFound) {
                detectedIds.add(t.id);
                reasons[t.id] = foundTriggers;
            }
        }

        // 3. Dependency Inference
        detectedIds.forEach(id => {
            if (FRAMEWORK_DEPENDENCIES[id]) {
                FRAMEWORK_DEPENDENCIES[id].forEach(dep => {
                    if (!detectedIds.has(dep)) {
                        detectedIds.add(dep);
                        reasons[dep] = [`Implied by ${id}`];
                    }
                });
            }
        });

        // 4. Safety Fallback
        if (rootFiles.includes('package.json') && !Array.from(detectedIds).some(id => ['react', 'vuejs', 'sveltekit', 'nextjs', 'angular', 'solidjs', 'qwik', 'astro'].includes(id))) {
             if (foundExtensions.has('.ts')) { detectedIds.add('typescript'); reasons['typescript'] = ['Found .ts files']; }
             if (foundExtensions.has('.js')) { detectedIds.add('javascript'); reasons['javascript'] = ['Found .js files']; }
        }

        return {
            ids: Array.from(detectedIds),
            reasons,
            gitStatus // Return the granular status
        };
    } catch (e) {
        console.error("Detection failed", e);
        return { ids: [], reasons: {}, gitStatus: 'none' };
    }
}

// Import the tree helper
import { generateTreeString, type TreeNode, scanDirectory } from '$lib/tree';

/**
 * 2. Process Files
 */
export async function processFiles(config: ProcessConfig): Promise<ProcessResult> {
    try {
        const sourceRoot = path.resolve(config.sourceDir);
        const projectName = path.basename(sourceRoot);

        // --- DETERMINE FILES TO PROCESS (OFFLOADED LOGIC) ---

        let filesToProcess: string[] = [];
        let filesForTree: string[] = []; // Separate list for the visual tree

        // 1. Setup Ignores
        const ignorePatterns = new Set<string>(['.git', 'node_modules', 'TXT-Forge', '.txt-forge-vault']);
        const massiveFolders = new Set<string>(['node_modules', '.git', '.svelte-kit', '.next', 'dist', 'build', 'vendor']); // Explicit massive folders

        const activeTemplates = templates.filter(t => config.templateIds.includes(t.id));
        activeTemplates.forEach(t => t.ignores.forEach(ign => ignorePatterns.add(ign.replace(/\/$/, ''))));

        // 2. Determine Content Files
        if (config.selectedFiles && config.selectedFiles.length > 0) {
            // MODE A: Explicit Selection

            const explicitFiles = new Set<string>();
            for (const relPath of config.selectedFiles) {
                const fullPath = path.join(sourceRoot, relPath);
                try {
                    const stat = await fs.stat(fullPath);
                    if (stat.isDirectory()) {
                        const dirFiles = await scanFiles(sourceRoot, fullPath, [], Array.from(ignorePatterns));
                        dirFiles.forEach(f => explicitFiles.add(f));
                    } else if (stat.isFile()) {
                        explicitFiles.add(fullPath);
                    }
                } catch (e) { }
            }
            filesToProcess = Array.from(explicitFiles);
        } else {
             // MODE B: Template Fallback
             const validExtensions = new Set<string>();
             activeTemplates.forEach(t => t.extensions.forEach(ext => validExtensions.add(ext)));
             filesToProcess = await scanFiles(sourceRoot, sourceRoot, Array.from(validExtensions), Array.from(ignorePatterns));
        }

        // 3. Determine Tree Files (The Visual Map)
        if (config.includeIgnoredInTree) {
            // If toggle ON: We want a broader scan.
            // We scan everything, BUT we stop at massive folders.
            // We pass an EMPTY extension list (accept all extensions).
            // We pass a minimal ignore list (only massive folders).
            const massiveIgnores = Array.from(massiveFolders);
            filesForTree = await scanFiles(sourceRoot, sourceRoot, [], massiveIgnores);
        } else {
            // If toggle OFF: Tree matches content exactly.
            filesForTree = [...filesToProcess];
        }

        // Sort tree alphabetically for display
        filesForTree.sort();
        const sourceTreeContent = filesForTree.map(f => path.relative(sourceRoot, f)).join('\n');

        if (filesToProcess.length === 0) return { success: false, message: "No matching files found.", outputPath: '', files: [] };

        // --- PREPARE OUTPUT (Keep existing logic) ---

        let outputBaseDir = '';
        if (config.saveMode === 'root') outputBaseDir = path.join(sourceRoot, 'TXT-Forge');
        else if (config.saveMode === 'global') outputBaseDir = path.join(os.homedir(), '.txt-forge-vault', projectName);
        else if (config.saveMode === 'custom' && config.customPath) outputBaseDir = path.resolve(config.customPath);
        else throw new Error("Invalid save path configuration.");

        let gitIgnoreModified = false;

        if (config.saveMode === 'root') {

            gitIgnoreModified = await ensureGitIgnore(sourceRoot);

        }

        const mergedDir = path.join(outputBaseDir, 'Merged');
        await cleanDirectory(mergedDir);

        // --- READ & MERGE (Keep existing logic) ---

        const fileMap: { original: string, relPath: string, content: string }[] = [];

        for (const filePath of filesToProcess) {
            try {
                // Size check for massive files check inside export
                const stats = await fs.stat(filePath);
                if (stats.size > 1024 * 1024 * 5) { // Skip > 5MB in content processing
                     console.warn(`Skipping huge file > 5MB: ${filePath}`);
                     continue;
                }

                const content = await fs.readFile(filePath, 'utf-8');
                const relPath = path.relative(sourceRoot, filePath);
                fileMap.push({ original: filePath, relPath, content });
            } catch (e) { }
        }

        // --- GENERATE FILES (Keep existing) ---

        const treeBody = sourceTreeContent.trim();
        const indentedBody = treeBody.split('\n').map(line => '‚îÇ   ' + line).join('\n');
        const finalTreeContent = `repository/\n${indentedBody}`;

        await fs.writeFile(path.join(mergedDir, 'Source-Tree.txt'), finalTreeContent, 'utf-8');

        const generatedFiles = await mergeFiles(fileMap, mergedDir, config.maxChars);

        generatedFiles.unshift('Source-Tree.txt');

        return {
            success: true,
            message: "Processing Complete",
            outputPath: mergedDir,
            files: generatedFiles,
            gitIgnoreModified // <--- Pass status
        };
    } catch (error: any) {
        return { success: false, message: error.message || "Unknown Error", outputPath: '', files: [] };
    }
}

// --- INTERNAL HELPERS ---

async function ensureGitIgnore(rootDir: string): Promise<boolean> {
    try {
        const gitIgnorePath = path.join(rootDir, '.gitignore');
        let content = "";

        try {
            content = await fs.readFile(gitIgnorePath, 'utf-8');
        } catch (e) {
            // File doesn't exist, we will create it
            content = "";
        }

        if (!content.includes('TXT-Forge')) {
            const append = content.endsWith('\n') || content === "" ? "TXT-Forge/" : "\nTXT-Forge/";
            await fs.appendFile(gitIgnorePath, append, 'utf-8');
            return true; // <--- Modified
        }
    } catch (e) {
        console.warn("Could not update .gitignore", e);
    }

    return false; // <--- Not Modified
}

async function cleanDirectory(dir: string) {
    try {
        await fs.rm(dir, { recursive: true, force: true });
        await fs.mkdir(dir, { recursive: true });
    } catch (e) {}
}

/**
 * Scans a few levels deep to find all active extensions in the project.
 * This allows us to detect "React" by finding .tsx files even if the config is weird.
 */
async function deepScanExtensions(dir: string, depth: number): Promise<Set<string>> {
    let extensions = new Set<string>();
    if (depth <= 0) return extensions;

    try {
        const list = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of list) {
            if (entry.name.startsWith('.') || entry.name === 'node_modules' || entry.name === 'dist' || entry.name === 'build' || entry.name === 'vendor') continue;

            if (entry.isDirectory()) {
                const subExts = await deepScanExtensions(path.join(dir, entry.name), depth - 1);
                subExts.forEach(e => extensions.add(e));
            } else {
                const ext = path.extname(entry.name);
                if (ext) extensions.add(ext);
            }
        }
    } catch (e) {
        // ADD THIS:
        logDebug(`Error scanning dir ${dir}:`, e);
    }

    return extensions;
}

async function scanFiles(rootDir: string, currentDir: string, extensions: string[], ignores: string[]): Promise<string[]> {
    let results: string[] = [];
    const list = await fs.readdir(currentDir, { withFileTypes: true });
    for (const entry of list) {
        const fullPath = path.join(currentDir, entry.name);
        const relPath = path.relative(rootDir, fullPath);

        // ... (Keep existing ignore logic) ...
        const pathParts = relPath.split(path.sep);
        const isIgnored = pathParts.some(part =>
            ignores.some(ign => {
                if (ign.startsWith('*')) return part.endsWith(ign.slice(1));
                return part === ign || part.toLowerCase() === ign.toLowerCase();
            })
        );
        if (isIgnored) continue;

        if (entry.isDirectory()) {
            results = results.concat(await scanFiles(rootDir, fullPath, extensions, ignores));
        } else {
            const ext = path.extname(entry.name);
            // UPDATED: If extensions list is empty, accept all (used for folder selection)
            if (extensions.length === 0 || extensions.includes(ext)) {
                results.push(fullPath);
            }
        }
    }
    return results;
}

/**
 * LINEAR MERGE (Next Fit)
 * Preserves file order from the source tree. Pushes multipart files to the end.
 */
async function mergeFiles(
    files: { relPath: string, content: string }[],
    outputDir: string,
    maxChars: number
): Promise<string[]> {

    const createdFiles: string[] = [];
    let fileIndex = 1;

    // 1. Separate Standard vs Multipart
    // We preserve the incoming order (Source Tree order) for standard files.
    const standardFiles: { relPath: string, fullText: string }[] = [];
    const multipartFiles: { relPath: string, content: string }[] = [];

    for (const file of files) {
        const header = `\n${'='.repeat(50)}\nFile: ${file.relPath}\n${'='.repeat(50)}\n\n`;
        const fullText = header + file.content + "\n\n";

        if (fullText.length > maxChars) {
            multipartFiles.push(file);
        } else {
            standardFiles.push({ relPath: file.relPath, fullText });
        }
    }

    // 2. Process Standard Files (Linear Fill)
    let currentBuffer = "";
    let currentBufferIndex: string[] = [];

    const flushBuffer = async () => {
        if (currentBuffer.length === 0) return;

        const filename = `Source-${fileIndex} (${currentBufferIndex.length} Files).txt`;
        const indexHeader = "--- INDEX ---\n" + currentBufferIndex.join('\n') + "\n" + "-".repeat(30) + "\n\n";

        await fs.writeFile(path.join(outputDir, filename), indexHeader + currentBuffer, 'utf-8');
        createdFiles.push(filename);

        fileIndex++;
        currentBuffer = "";
        currentBufferIndex = [];
    };

    for (const item of standardFiles) {
        // If adding this file exceeds limit, flush current buffer first
        if (currentBuffer.length + item.fullText.length > maxChars) {
            await flushBuffer();
        }

        currentBuffer += item.fullText;
        currentBufferIndex.push(item.relPath);
    }

    // Flush remaining standard files
    await flushBuffer();

    // 3. Process Multipart Files (At the end)
    for (const file of multipartFiles) {
        let remaining = file.content;
        let part = 1;
        const totalParts = Math.ceil(remaining.length / (maxChars - 500));

        while (remaining.length > 0) {
            const header = `\n${'='.repeat(50)}\nFile: ${file.relPath} (Part ${part}/${totalParts})\n${'='.repeat(50)}\n\n`;
            const availableSpace = maxChars - header.length;

            const filename = `Source-${fileIndex}.${part} (Multipart File).txt`;
            let contentToWrite = "";

            if (remaining.length <= availableSpace) {
                contentToWrite = header + remaining + "\n\n";
                remaining = "";
            } else {
                // Smart Split
                let splitIdx = -1;
                const searchWindow = remaining.substring(0, availableSpace);
                let match;
                SAFE_SPLIT_REGEX.lastIndex = 0;
                while ((match = SAFE_SPLIT_REGEX.exec(searchWindow)) !== null) {
                    splitIdx = match.index;
                }
                if (splitIdx === -1) splitIdx = searchWindow.lastIndexOf('\n');
                if (splitIdx === -1) splitIdx = availableSpace;

                contentToWrite = header + remaining.substring(0, splitIdx) + "\n\n";
                remaining = remaining.substring(splitIdx);
            }

            const indexHeader = "--- INDEX ---\n" + `${file.relPath} (Part ${part}/${totalParts})` + "\n" + "-".repeat(30) + "\n\n";
            await fs.writeFile(path.join(outputDir, filename), indexHeader + contentToWrite, 'utf-8');
            createdFiles.push(filename);
            part++;
        }
        fileIndex++;
    }

    return createdFiles;
}



==================================================
File: src\lib\server\logger.js
==================================================

export function logDebug(message, data = null) {
    if (process.env.TXT_FORGE_DEBUG === 'true') {
        const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
        console.log(`\x1b[35m[DEBUG ${timestamp}]\x1b[0m ${message}`);
        if (data) {
            console.dir(data, { depth: 2, colors: true });
        }
    }
}



==================================================
File: src\lib\server\sys-utils.js
==================================================

import fs from 'fs';
import path from 'path';
import os from 'os';
import { spawn } from 'child_process';

const CONFIG_DIR = path.join(os.homedir(), '.txt-forge');
const CONFIG_FILE = path.join(CONFIG_DIR, 'config.json');

// Ensure config directory exists
if (!fs.existsSync(CONFIG_DIR)) {
    fs.mkdirSync(CONFIG_DIR, { recursive: true });
}

export function loadConfig() {
    try {
        if (fs.existsSync(CONFIG_FILE)) {
            return JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf-8'));
        }
    } catch (e) {
        console.error("Failed to load config", e);
    }
    return { lastCustomPath: null };
}

export function saveConfig(data) {
    try {
        const current = loadConfig();
        fs.writeFileSync(CONFIG_FILE, JSON.stringify({ ...current, ...data }, null, 2));
    } catch (e) {
        console.error("Failed to save config", e);
    }
}

export async function pickDirectory() {
    const platform = os.platform();
    let command = '';
    let args = [];

    if (platform === 'win32') {
        // PowerShell hack: Use OpenFileDialog with 'Select Folder' as filename to force modern UI
        command = 'powershell';
        args = [
            '-NoProfile',
            '-Command',
            `
            Add-Type -AssemblyName System.Windows.Forms
            $f = New-Object System.Windows.Forms.OpenFileDialog
            $f.ValidateNames = $false
            $f.CheckFileExists = $false
            $f.CheckPathExists = $true
            $f.FileName = "Select Folder"
            $f.Title = "Select Output Folder"
            $f.Filter = "Folders|no.files"
            if ($f.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
                Write-Host ([System.IO.Path]::GetDirectoryName($f.FileName))
            }
            `
        ];
    } else if (platform === 'darwin') {
        // AppleScript to choose folder
        command = 'osascript';
        args = ['-e', 'POSIX path of (choose folder)'];
    } else if (platform === 'linux') {
        // Zenity
        command = 'zenity';
        args = ['--file-selection', '--directory'];
    }

    return new Promise((resolve, reject) => {
        const child = spawn(command, args);
        let stdout = '';
        let stderr = '';

        child.stdout.on('data', (data) => { stdout += data.toString(); });
        child.stderr.on('data', (data) => { stderr += data.toString(); });

        child.on('close', (code) => {
            // Ensure we get a clean string
            const result = stdout.trim();
            if (code === 0 && result && result !== "Select Folder") {
                 // The PowerShell hack sometimes returns the filename appended, ensure we return the directory
                 // But the script above explicitly prints GetDirectoryName, so result is correct.
                resolve(result);
            } else {
                resolve(null);
            }
        });
    });
}



==================================================
File: src\lib\templates.ts
==================================================

export interface CodebaseTemplate {
  id: string;
  name: string;
  extensions: string[];
  ignores: string[];
  iconUrl: string;
  triggers: string[];
}

export const templates: CodebaseTemplate[] = [
  {
    id: "typescript",
    name: "TypeScript",
    extensions: [".ts", ".tsx", ".d.ts", ".mts", ".cts"],
    ignores: [
      "*.tsbuildinfo",
      "dist/",
      "build/",
      ".tsc/",
      "out/",
      "package-lock.json", // <--- ADDED
      "yarn.lock",         // <--- ADDED
      "pnpm-lock.yaml",    // <--- ADDED
      "bun.lockb"          // <--- ADDED
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/typescript.svg",
    triggers: ["tsconfig.json", "package.json"],
  },
  {
    id: "python",
    name: "Python",
    extensions: [
      ".py",
      ".pyc",
      ".pyo",
      ".pyd",
      ".pyw",
      ".pyz",
      ".pyi",
      ".pyx",
    ],
    ignores: [
      "__pycache__/",
      "*.py[cod]",
      "*$py.class",
      "*.so",
      ".Python",
      "env/",
      "venv/",
      ".venv",
      "build/",
      "develop-eggs/",
      "dist/",
      "downloads/",
      "eggs/",
      ".eggs/",
      "lib/",
      "lib64/",
      "parts/",
      "sdist/",
      "var/",
      "wheels/",
      "*.egg-info/",
      ".installed.cfg",
      "*.egg",
      "pip-log.txt",
      "pip-delete-this-directory.txt",
      ".pytest_cache/",
      ".coverage",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/python.svg",
    triggers: ["requirements.txt", "setup.py", "pyproject.toml"],
  },
  {
    id: "javascript",
    name: "JavaScript",
    extensions: [".js", ".cjs", ".mjs", ".jsx", ".jsm", ".jsonc"],
    ignores: [
      "node_modules/",
      "npm-debug.log*",
      "yarn-debug.log*",
      "yarn-error.log*",
      "package-lock.json",
      "yarn.lock",
      "pnpm-lock.yaml",
      ".env",
      ".env.local",
      "dist/",
      "build/",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/javascript.svg",
    triggers: ["package.json", ".npmrc"],
  },
  {
    id: "html-css",
    name: "HTML/CSS",
    extensions: [
      ".html",
      ".htm",
      ".xhtml",
      ".css",
      ".scss",
      ".sass",
      ".less",
      ".postcss",
    ],
    ignores: [
      ".cache/",
      ".parcel-cache/",
      "*.css.map",
      "*.sass.map",
      "*.scss.map",
      "dist/",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/html5.svg",
    triggers: ["index.html", "style.css"],
  },
  {
    id: "sql",
    name: "SQL",
    extensions: [".sql", ".psql", ".hql", ".ddl", ".dml"],
    ignores: [
      "*.db",
      "*.sqlite",
      "*.sqlite3",
      "*.mdb",
      "*.accdb",
      "*.sqlitedb",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/mysql.svg",
    triggers: ["schema.sql", "migrations/"],
  },
  {
    id: "java",
    name: "Java",
    extensions: [
      ".java",
      ".class",
      ".jar",
      ".war",
      ".ear",
      ".jvm",
      ".gradle",
      ".maven",
    ],
    ignores: [
      "target/",
      "*.class",
      "*.jar",
      "*.war",
      "*.ear",
      ".gradle/",
      "build/",
      ".idea/",
      "*.iml",
      "out/",
      "*.log",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/java.svg",
    triggers: ["pom.xml", "build.gradle"],
  },
  {
    id: "csharp",
    name: "C#",
    extensions: [".cs", ".csproj", ".sln", ".cshtml", ".csx", ".cake", ".razor"],
    ignores: [
      "bin/",
      "obj/",
      "*.suo",
      "*.user",
      ".vs/",
      ".vscode/",
      "*.userprefs",
      "packages/",
      "*.nupkg",
      "project.lock.json",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/csharp.svg",
    triggers: ["*.csproj", "*.sln"],
  },
  {
    id: "cpp",
    name: "C++",
    extensions: [
      ".cpp",
      ".cc",
      ".cxx",
      ".c++",
      ".h",
      ".hpp",
      ".hh",
      ".hxx",
      ".inl",
      ".ipp",
      ".tcc",
    ],
    ignores: [
      "*.o",
      "*.obj",
      "*.exe",
      "*.out",
      "*.app",
      "*.a",
      "*.so",
      "*.dylib",
      "Debug/",
      "Release/",
      "x64/",
      "x86/",
      "CMakeFiles/",
      "CMakeCache.txt",
      "cmake_install.cmake",
      "Makefile",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/cplusplus.svg",
    triggers: ["CMakeLists.txt", "*.vcxproj"],
  },
  {
    id: "go",
    name: "Go",
    extensions: [".go", ".mod", ".sum"],
    ignores: [
      "*.exe",
      "*.dll",
      "*.so",
      "*.dylib",
      "vendor/",
      "*.test",
      "dist/",
      "bin/",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/go.svg",
    triggers: ["go.mod", "go.sum"],
  },
  {
    id: "rust",
    name: "Rust",
    extensions: [".rs", ".rlib", ".rmeta"],
    ignores: ["target/", "Cargo.lock", "*.pdb", "dist/", "*.swp"],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/rust.svg",
    triggers: ["Cargo.toml", "Cargo.lock"],
  },
  {
    id: "php",
    name: "PHP",
    extensions: [
      ".php",
      ".php3",
      ".php4",
      ".php5",
      ".phtml",
      ".phps",
      ".phar",
    ],
    ignores: [
      "/vendor/",
      "composer.lock",
      ".env",
      ".phpunit.result.cache",
      "node_modules/",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/php.svg",
    triggers: ["composer.json", "composer.lock"],
  },
  {
    id: "kotlin",
    name: "Kotlin",
    extensions: [".kt", ".kts", ".ktm", ".gradle"],
    ignores: ["*.class", "build/", ".idea/", "*.iml", "out/", ".gradle/"],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/kotlin.svg",
    triggers: ["build.gradle.kts", "pom.xml"],
  },
  {
    id: "swift",
    name: "Swift",
    extensions: [".swift", ".swifttemplate", ".xcodeproj"],
    ignores: [
      "xcuserdata/",
      "*.xcuserstate",
      "build/",
      "*.ipa",
      ".build/",
      ".swiftpm/",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/swift.svg",
    triggers: ["Package.swift", "*.xcodeproj"],
  },
  {
    id: "ruby",
    name: "Ruby",
    extensions: [".rb", ".rbw", ".rake", ".gemspec", ".erb"],
    ignores: [
      "*.gem",
      ".bundle",
      "vendor/bundle",
      ".rvmrc",
      ".ruby-version",
      "Gemfile.lock",
      ".byebug_history",
      "tmp/",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/ruby.svg",
    triggers: ["Gemfile", "Gemfile.lock"],
  },
  {
    id: "bash-shell",
    name: "Bash/Shell",
    extensions: [".sh", ".bash", ".zsh", ".fish", ".ksh", ".csh"],
    ignores: ["*.swp", "*.swo", "*~", ".bash_history", ".zsh_history"],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/gnubash.svg",
    triggers: ["*.sh"],
  },
  {
    id: "c",
    name: "C",
    extensions: [".c", ".h", ".idc", ".w"],
    ignores: ["*.o", "*.obj", "*.a", "*.exe", "*.out", "*.so", "*.dylib"],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/c.svg",
    triggers: ["Makefile", "*.h"],
  },
  {
    id: "r",
    name: "R",
    extensions: [".r", ".R", ".Rmd", ".RData", ".rds", ".Rproj"],
    ignores: [".Rhistory", ".RData", ".Ruserdata", ".Rproj.user/"],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/r.svg",
    triggers: [".Rproj", "DESCRIPTION"],
  },
  {
    id: "scala",
    name: "Scala",
    extensions: [".scala", ".sc", ".sbt"],
    ignores: ["target/", ".idea/", "*.class", "*.jar"],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/scala.svg",
    triggers: ["build.sbt", "project/"],
  },
  {
    id: "perl",
    name: "Perl",
    extensions: [".pl", ".pm", ".t", ".pod", ".cgi"],
    ignores: ["*.perlcritic", "cover_db/", "*.o", "blib/"],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/perl.svg",
    triggers: ["Makefile.PL", "cpanfile"],
  },
  {
    id: "dart",
    name: "Dart",
    extensions: [".dart", ".dill", ".g.dart"],
    ignores: [".dart_tool/", ".pub-cache/", ".pub/", "build/", "*.g.dart"],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/dart.svg",
    triggers: ["pubspec.yaml", "pubspec.lock"],
  },
  {
    id: "elixir",
    name: "Elixir",
    extensions: [".ex", ".exs", ".eex", ".leex"],
    ignores: [
      "_build/",
      "deps/",
      ".fetch",
      "erl_crash.dump",
      "*.ez",
      "*.beam",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/elixir.svg",
    triggers: ["mix.exs", "mix.lock"],
  },
  {
    id: "lua",
    name: "Lua",
    extensions: [".lua", ".luac", ".lua5.1", ".rockspec"],
    ignores: ["*.luac", "luac.out"],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/lua.svg",
    triggers: ["*.rockspec"],
  },
  {
    id: "assembly",
    name: "Assembly",
    extensions: [".asm", ".s", ".S", ".nasm", ".a51", ".inc", ".obj"],
    ignores: ["*.o", "*.obj", "*.exe", "*.bin", "*.hex"],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/assemblyscript.svg",
    triggers: ["Makefile"],
  },
  {
    id: "groovy",
    name: "Groovy",
    extensions: [".groovy", ".gvy", ".gy", ".gsh", ".gradle"],
    ignores: ["*.class", "build/", ".gradle/"],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/groovy.svg",
    triggers: ["build.gradle", "Jenkinsfile"],
  },
  {
    id: "vb-net",
    name: "Visual Basic .NET",
    extensions: [".vb", ".vba", ".vbs", ".frm", ".cls"],
    ignores: ["bin/", "obj/", "*.suo", "*.user"],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/dotnet.svg",
    triggers: ["*.vbproj", "*.sln"],
  },
  {
    id: "react",
    name: "React",
    extensions: [".js", ".jsx", ".ts", ".tsx"],
    ignores: [
      "node_modules/",
      "build/",
      "dist/",
      ".env",
      ".env.local",
      "npm-debug.log*",
      "yarn-debug.log*",
      "coverage/",
      ".eslintcache",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/react.svg",
    triggers: ["package.json", "*.jsx", "*.tsx"],
  },
  {
    id: "nextjs",
    name: "Next.js",
    extensions: [".js", ".jsx", ".ts", ".tsx"],
    ignores: [
      ".next/",
      "out/",
      "build/",
      "dist/",
      ".vercel",
      "*.tsbuildinfo",
      "node_modules/",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/nextdotjs.svg",
    // ADDED: next.config.mjs, next.config.ts, next.config.cjs
    triggers: ["next.config.js", "next.config.mjs", "next.config.ts", "next.config.cjs", "package.json"],
  },
  {
    id: "django",
    name: "Django",
    extensions: [],
    ignores: [
      "*.log",
      "*.pot",
      "*.pyc",
      "__pycache__/",
      "db.sqlite3",
      "media/",
      "staticfiles/",
      "venv/",
      ".env",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/django.svg",
    triggers: ["manage.py", "wsgi.py"],
  },
  {
    id: "vuejs",
    name: "Vue.js",
    extensions: [".js", ".jsx", ".ts", ".tsx", ".vue"],
    ignores: [
      "node_modules/",
      "/dist",
      "/build",
      ".env",
      ".env.local",
      "npm-debug.log*",
      "yarn-debug.log*",
      ".eslintcache",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/vuedotjs.svg",
    triggers: ["package.json", "*.vue"],
  },
  {
    id: "spring-boot",
    name: "Spring Boot",
    extensions: [".properties", ".yml", ".yaml"],
    ignores: [
      "target/",
      "*.jar",
      "*.war",
      "*.ear",
      ".gradle/",
      "build/",
      "out/",
      ".idea/",
      "*.iml",
      ".classpath",
      ".project",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/springboot.svg",
    triggers: ["pom.xml", "build.gradle", "application.properties"],
  },
  {
    id: "expressjs",
    name: "Express.js",
    extensions: [".js", ".ts"],
    ignores: [
      "node_modules/",
      "npm-debug.log*",
      "yarn-debug.log*",
      "yarn-error.log*",
      ".env",
      ".env.local",
      "dist/",
      "build/",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/express.svg",
    triggers: ["package.json", "server.js", "index.js"],
  },
  {
    id: "angular",
    name: "Angular",
    extensions: [".ts", ".tsx", ".html", ".css"],
    ignores: [
      "dist/",
      ".angular/",
      "node_modules/",
      "npm-debug.log*",
      "yarn-error.log*",
      ".vscode/",
      ".idea/",
      "*.swp",
      "*.swo",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/angular.svg",
    triggers: ["angular.json", "package.json"],
  },
  {
    id: "nuxtjs",
    name: "Nuxt.js",
    extensions: [".js", ".jsx", ".ts", ".tsx", ".vue"],
    ignores: [
      ".nuxt/",
      "dist/",
      "node_modules/",
      "npm-debug.log*",
      "yarn-debug.log*",
      ".env",
      ".env.local",
      ".output/",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/nuxtdotjs.svg",
    triggers: ["nuxt.config.ts", "package.json"],
  },
  {
    id: "remix",
    name: "Remix",
    extensions: [".js", ".jsx", ".ts", ".tsx"],
    ignores: [
      "build/",
      "dist/",
      ".remix",
      "node_modules/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      ".vercel",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/remix.svg",
    triggers: ["remix.config.js", "package.json"],
  },
  {
    id: "sveltekit",
    name: "SvelteKit",
    extensions: [".js", ".ts", ".svelte"],
    ignores: [
      ".svelte-kit/",
      "build/",
      "dist/",
      "node_modules/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      "vite.config.js.timestamp-*",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/svelte.svg",
    triggers: ["svelte.config.js", "package.json"],
  },
  {
    id: "astro",
    name: "Astro",
    extensions: [".js", ".ts", ".astro"],
    ignores: [
      "dist/",
      ".astro/",
      "node_modules/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      ".vercel",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/astro.svg",
    triggers: ["astro.config.mjs", "package.json"],
  },
  {
    id: "qwik",
    name: "Qwik",
    extensions: [".js", ".ts", ".jsx", ".tsx"],
    ignores: [
      "dist/",
      ".qwik/",
      "node_modules/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      ".vercel",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/qwik.svg",
    triggers: ["qwik.config.ts", "package.json"],
  },
  {
    id: "nestjs",
    name: "NestJS",
    extensions: [".ts"],
    ignores: [
      "dist/",
      "node_modules/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      ".vercel",
      "coverage/",
      ".nyc_output/",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/nestjs.svg",
    triggers: ["package.json", "src/main.ts"],
  },
  {
    id: "fastify",
    name: "Fastify",
    extensions: [".js", ".ts"],
    ignores: [
      "dist/",
      "node_modules/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      "coverage/",
      ".nyc_output/",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/fastify.svg",
    triggers: ["package.json", "server.js"],
  },
  {
    id: "koa",
    name: "Koa",
    extensions: [".js", ".ts"],
    ignores: [
      "dist/",
      "node_modules/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      "coverage/",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/koa.svg",
    triggers: ["package.json", "index.js"],
  },
  {
    id: "meteorjs",
    name: "Meteor.js",
    extensions: [".js", ".jsx", ".ts", ".tsx"],
    ignores: [
      "node_modules/",
      ".meteor/local/",
      ".meteor/dev_bundle/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      "dist/",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/meteor.svg",
    triggers: ["package.json", ".meteor/"],
  },
  {
    id: "solidjs",
    name: "SolidJS",
    extensions: [".js", ".ts", ".jsx", ".tsx"],
    ignores: [
      "dist/",
      ".solid/",
      "node_modules/",
      "npm-debug.log*",
      ".env",
      ".env.local",
      "coverage/",
    ],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/solid.svg",
    triggers: ["vite.config.ts", "package.json"],
  },
  {
    id: "laravel",
    name: "Laravel",
    extensions: [],
    ignores: [
      "/vendor/",
      "node_modules/",
      "npm-debug.log*",
      "yarn-error.log*",
      ".env",
      ".env.local",
      "storage/",
      "bootstrap/cache/",
      ".vscode/",
      ".idea/",
      "composer.lock",
      "package-lock.json",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/laravel.svg",
    triggers: ["artisan", "composer.json"],
  },
  {
    id: "godot4",
    name: "Godot 4",
    extensions: [".gd", ".gdshader", ".gdscript", ".tscn", ".tres"],
    ignores: [
      ".godot/",
      ".mono/",
      "export/",
      "*.import",
      "*.generated",
      "user_data/",
      ".DS_Store",
      "Thumbs.db",
      "*.log",
      ".cache/",
      "*.swp",
      "*.swo",
      "*~",
    ],
    iconUrl:
      "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/godotengine.svg",
    triggers: ["project.godot", "*.tscn"],
  },
  {
    id: "docker",
    name: "Docker",
    extensions: ["Dockerfile", ".dockerignore", ".yml", ".yaml"],
    ignores: [],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/docker.svg",
    triggers: ["Dockerfile", "docker-compose.yml", "docker-compose.yaml", "docker-compose.dev.yml"],
  },
  {
    id: "prisma",
    name: "Prisma",
    extensions: [".prisma"],
    ignores: ["migrations/"],
    iconUrl: "https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/prisma.svg",
    triggers: ["schema.prisma", "prisma/"],
  },
];

/**
 * Universal .gitignore patterns for all projects
 */
export const universalGitignorePatterns = [
  "# OS Files & Metadata",
  "ehthumbs.db",
  "Desktop.ini",
  ".AppleDouble",
  ".LSOverride",
  "._*",
  ".Spotlight-V100",
  ".Trashes",
  ".TemporaryItems",
  "Thumbs.db.lock",
  ".fseventsd",
  ".fuse_hidden*",
  "",
  "# Package Managers / Lock Files", // <--- ADDED SECTION
  "package-lock.json",
  "yarn.lock",
  "pnpm-lock.yaml",
  "bun.lockb",
  "",
  "# Editor Configuration",
  ".sublime-project",
  ".sublime-workspace",
  ".atom/",
  ".nova/",
  ".editorconfig",
  ".c9/",
  "",
  "# Security Files",
  "*.key",
  "*.pem",
  "*.p12",
  "*.pfx",
  "*.jks",
  "*.cert",
  "*.crt",
  "*.der",
  "secrets/",
  "private/",
  "credentials/",
  "",
  "# Temporary & Backup Files",
  "*.bak",
  "*.tmp",
  "*.backup",
  "backup/",
  ".backup/",
  "*.orig",
  "",
  "# Miscellaneous",
  ".directory",
  ".netrc",
  "*.svg",
  "*.mp4",
  "*.mp3",
  "*.jpg",
  "*.png",
];

/**
 * Find a template by ID
 */
export function findTemplateById(id: string): CodebaseTemplate | undefined {
  return templates.find((template) => template.id === id);
}

/**
 * Find a template by name
 */
export function findTemplateByName(
  name: string
): CodebaseTemplate | undefined {
  return templates.find((template) =>
    template.name.toLowerCase().includes(name.toLowerCase())
  );
}

/**
 * Detect templates based on file triggers
 */
export function detectTemplatesByFiles(
  fileNames: string[]
): CodebaseTemplate[] {
  const detectedTemplates = new Set<CodebaseTemplate>();

  for (const template of templates) {
    for (const fileName of fileNames) {
      if (template.triggers.some((trigger) => fileName.includes(trigger))) {
        detectedTemplates.add(template);
        break;
      }
    }
  }

  return Array.from(detectedTemplates);
}

/**
 * Generate combined .gitignore content for multiple templates
 */
export function generateGitignore(templateIds: string[]): string {
  const ignorePatterns = new Set<string>(universalGitignorePatterns);
  const templateNames: string[] = [];

  for (const id of templateIds) {
    const template = findTemplateById(id);
    if (template) {
      templateNames.push(template.name);
      template.ignores.forEach((pattern) => ignorePatterns.add(pattern));
    }
  }

  let gitignore = "";

  if (templateNames.length > 0) {
    gitignore += `# ${templateNames.join(", ")} Configuration\n`;
    gitignore += Array.from(ignorePatterns)
      .filter((pattern) => pattern.trim().length > 0)
      .join("\n");
  }

  return gitignore;
}


==================================================
File: src\lib\tree.ts
==================================================

import fs from 'fs/promises';
import path from 'path';

// ADD THIS:
import { logDebug } from '$lib/server/logger.js';

export interface TreeNode {
    name: string;
    path: string; // Relative path from root
    type: 'file' | 'folder';
    children?: TreeNode[];
    isIgnored: boolean; // True if matched by .gitignore or system hidden
    isMedia: boolean;
    // ADD THIS:
    isMassive: boolean;
    depth: number;
}

const SYSTEM_HIDDEN = [
    '.git',
    '.DS_Store',
    'Thumbs.db',
    'node_modules',
    '.svelte-kit',
    '.txt-forge-vault',
    'TXT-Forge',
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml',
    'bun.lockb'
];

// ADD THIS LIST:

const MEDIA_EXTENSIONS = new Set([
    '.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico', '.svg', '.bmp', '.tiff',
    '.mp3', '.wav', '.ogg', '.mp4', '.webm', '.mov', '.avi',
    '.pdf', '.zip', '.tar', '.gz', '.7z', '.rar',
    '.exe', '.dll', '.so', '.dylib', '.bin',
    '.ttf', '.otf', '.woff', '.woff2', '.eot'
]);

const MASSIVE_FOLDERS = new Set([
    'node_modules', 'bower_components', 'vendor',
    '.git', '.svn', '.hg',
    '.svelte-kit', '.next', '.nuxt', '.output',
    'dist', 'build', 'out', 'target',
    'CMakeFiles', '.gradle', '.idea', '.vscode'
]);

const MAX_FOLDER_ITEMS = 150;
const MAX_FILE_SIZE_MB = 1 * 1024 * 1024; // 1MB

/**
 * specific ignore logic for the tree view (lighter than the full processor)
 */
function isSystemIgnored(name: string): boolean {
    return SYSTEM_HIDDEN.includes(name) || name.startsWith('.');
}

export async function scanDirectory(
    rootDir: string,
    currentDir: string,
    depth: number = 0,
    additionalIgnores: string[] = [],
    isLazyLoadRoot: boolean = false // <--- NEW PARAMETER
): Promise<TreeNode[]> {
    logDebug(`Scanning directory: ${currentDir} (Depth: ${depth})`);

    const nodes: TreeNode[] = [];
    let entries: import('fs').Dirent[] = [];
    try {
        entries = await fs.readdir(currentDir, { withFileTypes: true });
    } catch (e) {
        return [];
    }

    // --- MASSIVE FOLDER CHECK (Optimized) ---

    // If this folder has too many items, we mark it massive and STOP here.

    // EXCEPTION: If this is the specific folder the user requested to expand (isLazyLoadRoot),

    // we MUST process its immediate children, otherwise the UI shows nothing.

    const isTooManyItems = entries.length > MAX_FOLDER_ITEMS;

    const dirName = path.basename(currentDir);

    const isKnownMassive = MASSIVE_FOLDERS.has(dirName);

    // If we are deep in recursion OR (it is massive AND NOT the root of this specific scan request)

    if (depth > 0 && (isKnownMassive || isTooManyItems) && !isLazyLoadRoot) {

        return []; // Returning empty triggers the "Massive" state in the parent node logic

    }

    // -------------------------------------------

    // Merge passed ignores with local .gitignore...
    const activeIgnores = [...additionalIgnores];
    const gitIgnorePath = path.join(currentDir, '.gitignore');
    try {
        const gitIgnoreContent = await fs.readFile(gitIgnorePath, 'utf-8');
        gitIgnoreContent.split('\n').forEach(line => {
            const l = line.trim();
            if (l && !l.startsWith('#')) activeIgnores.push(l);
        });
    } catch (e) { }

    // Sort: Folders first, then files
    entries.sort((a, b) => {
        if (a.isDirectory() && !b.isDirectory()) return -1;
        if (!a.isDirectory() && b.isDirectory()) return 1;
        return a.name.localeCompare(b.name);
    });

    for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name);
        const relPath = path.relative(rootDir, fullPath);
        const normalizedRelPath = relPath.split(path.sep).join('/');
        const isDirectory = entry.isDirectory();

        // Check simple ignore logic (System files)...
        let isIgnored = isSystemIgnored(entry.name);
        if (!isIgnored) {
             isIgnored = activeIgnores.some(pattern => {
                // ... existing regex logic ...
                let p = pattern.trim();
                if (!p || p.startsWith('#')) return false;
                if (p.startsWith('!')) return false;
                p = p.replace(/\\/g, '/');
                const isDirPattern = p.endsWith('/');
                if (isDirPattern) {
                    p = p.slice(0, -1);
                    if (!isDirectory) return false;
                }
                if (p.startsWith('*')) return entry.name.endsWith(p.slice(1));
                if (p.startsWith('/')) {
                    const clean = p.slice(1);
                    return normalizedRelPath === clean || normalizedRelPath.startsWith(clean + '/');
                }
                if (!p.includes('/')) return entry.name === p;
                return normalizedRelPath === p || normalizedRelPath.startsWith(p + '/');
             });
        }

        // --- MASSIVE & MEDIA CHECKS ---

        const ext = path.extname(entry.name).toLowerCase();
        const isMedia = !isDirectory && MEDIA_EXTENSIONS.has(ext);

        let isMassive = false;
        let children: TreeNode[] | undefined = undefined;
        if (isDirectory) {
            // Check if THIS specific child folder is known massive (e.g. node_modules)
            // If so, we mark it massive and DO NOT recurse.
            if (MASSIVE_FOLDERS.has(entry.name)) {
                isMassive = true;
                children = []; // Empty children = Massive/Lazy Load
            } else {
                // Recurse normally
                // Pass false for isLazyLoadRoot because children of the lazy load root are not exempt
                children = await scanDirectory(rootDir, fullPath, depth + 1, activeIgnores, false);
            }
        } else {
            // Check File Size
            try {
                const stats = await fs.stat(fullPath);
                if (stats.size > MAX_FILE_SIZE_MB) isMassive = true;
            } catch(e) {}
        }

        // ------------------------------

        const node: TreeNode = {
            name: entry.name,
            path: relPath,
            type: isDirectory ? 'folder' : 'file',
            isIgnored: isIgnored,
            isMedia: isMedia,
            isMassive: isMassive, // <--- NEW
            children: children,
            depth: depth
        };

        nodes.push(node);
    }

    return nodes;
}

/**
 * Generates a visual tree string for the Source-Tree.txt file
 */
export function generateTreeString(nodes: TreeNode[], selectedPaths: Set<string>, prefix = ''): string {
    let output = '';

    // Filter nodes that are effectively enabled
    // A node is visible if it is in selectedPaths OR if it's a folder that contains selected paths
    // However, for Source-Tree.txt, we usually just want to show exactly what is enabled.

    const validNodes = nodes.filter(n => selectedPaths.has(n.path));

    for (let i = 0; i < validNodes.length; i++) {
        const node = validNodes[i];
        const isLast = i === validNodes.length - 1;
        const connector = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
        const childPrefix = isLast ? '    ' : '‚îÇ   ';
        output += prefix + connector + node.name + (node.type === 'folder' ? '/' : '') + '\n';
        if (node.children && node.children.length > 0) {
            output += generateTreeString(node.children, selectedPaths, prefix + childPrefix);
        }
    }
    return output;
}



==================================================
File: src\routes\+layout.svelte
==================================================

<script lang="ts">
	import '../app.css';

	// 1. Import the images from your lib folder
	import faviconSvg from '$lib/assets/favicon.svg';
	import faviconPng from '$lib/assets/favicon.png';

	let { children } = $props();
</script>

<!-- 2. Inject them into the document head -->
<svelte:head>
	<title>TXT-Forge: Source to Text</title>

	<link rel="icon" href={faviconPng} sizes="any" />
	<link rel="icon" href={faviconSvg} type="image/svg+xml" />
	<link rel="apple-touch-icon" href={faviconPng} />
    <style>
        /* Global dark scrollbar fix for the entire app */
        :global(html) {
            background-color: #020617; /* Slate 950 (Void) */
            color-scheme: dark;
        }

        /* Webkit (Chrome, Safari, Edge) scrollbar customization */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #020617;
        }
        ::-webkit-scrollbar-thumb {
            background: #334155; /* Slate 700 */
            border-radius: 5px;
            border: 2px solid #020617;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #f97316; /* Orange 500 (Magma) */
        }
    </style>
</svelte:head>

{@render children()}


